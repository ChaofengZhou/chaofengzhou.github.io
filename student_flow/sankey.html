<!DOCTYPE html>
<meta charset="utf-8">
<title>SANKEY Experiment</title>
<style>
.node rect {
  cursor: move;
  fill-opacity: .9;
  shape-rendering: crispEdges;
}

.node text {
  pointer-events: none;
  text-shadow: 0 1px 0 #fff;
}

.link {
  fill: none;
  stroke-opacity: .3;
}

text {
  font-size: 12px;
}
</style>

<body>
  <p id="chart">
    <script src="http://d3js.org/d3.v3.min.js"></script>
    <script src="sankey.js"></script>
    <script>
    var units = "Widgets";

    var margin = {
        top: 10,
        right: 10,
        bottom: 10,
        left: 10
      },
      width = 510 - margin.left - margin.right,
      height = 830 - margin.top - margin.bottom;

    var formatNumber = d3.format(",.0f"), // zero decimal places
      format = function(d) {
        return formatNumber(d) + " " + units;
      },
      color = d3.scale.category20();

    // append the svg canvas to the page
    var svg = d3.select("#chart").append("svg")
      .attr("width", width + margin.left + margin.right + 170)
      .attr("height", height + margin.top + margin.bottom)
      .append("g")
      .attr("transform",
        "translate(" + margin.left + "," + margin.top + ")");

    // Set the sankey diagram properties
    var sankey = d3.sankey()
      .nodeWidth(27)
      .nodePadding(7)
      .size([width, height]);

    var path = sankey.link();

    // load the data (using the timelyportfolio csv method)
    d3.csv("sankey.csv", function(error, data) {

      //set up graph in same style as original example but empty
      graph = {
        "nodes": [],
        "links": []
      };

      data.forEach(function(d) {
        graph.nodes.push({
          "name": d.source
        });
        graph.nodes.push({
          "name": d.target
        });
        graph.links.push({
          "source": d.source,
          "target": d.target,
          "value": +d.value
        });
      });

      // return only the distinct / unique nodes
      graph.nodes = d3.keys(d3.nest()
        .key(function(d) {
          return d.name;
        })
        .map(graph.nodes));

      // console.log(graph.nodes);

      // loop through each link replacing the text with its index from node
      graph.links.forEach(function(d, i) {
        graph.links[i].source = graph.nodes.indexOf(graph.links[i].source);
        graph.links[i].target = graph.nodes.indexOf(graph.links[i].target);
      });

      //now loop through each nodes to make nodes an array of objects
      // rather than an array of strings
      graph.nodes.forEach(function(d, i) {
        graph.nodes[i] = {
          "name": d
        };
      });

      sankey
        .nodes(graph.nodes)
        .links(graph.links)
        .layout(32);

      // add in the links
      var link = svg.append("g").selectAll(".link")
        .data(graph.links)
        .enter().append("path")
        .attr("class", "link")
        .attr("d", path)
        .attr("class", function(d) {
          return "link source_" + nameHash(d.source.name) + " target_" + nameHash(d.target.name);
        })
        .style("stroke-width", function(d) {
          return Math.max(1, d.dy);
        })
        .sort(function(a, b) {
          return b.dy - a.dy;
        });

      // add the link titles
      link.append("title")
        .text(function(d) {
          return d.source.name + " â†’ " +
            d.target.name + "\n" + format(d.value);
        });

      // add in the nodes
      var node = svg.append("g").selectAll(".node")
        .data(graph.nodes)
        .enter().append("g")
        .attr("class", "node")
        .attr("transform", function(d, i) {
          return "translate(" + d.x + "," + d.y + ")";
        })
        .call(d3.behavior.drag()
          .origin(function(d) {
            return d;
          })
          .on("dragstart", function() {
            this.parentNode.appendChild(this);
          })
          .on("drag", dragmove))
        .on("mouseover", function(d) {
          var name = nameHash(d.name);
          if (d.name.endsWith("0")) {
            svg.selectAll(".link")
              .style("stroke-opacity", 0);
            svg.selectAll(".source_" + name.substring(0, name.length - 1) + "0")
              .style("stroke-opacity", 0.4)
              .style("stroke", function(d) {
                return colorConvert(d);
              })
            svg.selectAll(".source_" + name.substring(0, name.length - 1) + "1")
              .style("stroke-opacity", 0.4)
              .style("stroke", function(d) {
                return colorConvert(d);
              })
          } else if (d.name.endsWith("1")) {
            svg.selectAll(".link")
              .style("stroke-opacity", 0);
            svg.selectAll(".source_" + name)
              .style("stroke-opacity", 0.4)
              .style("stroke", function(d) {
                return colorConvert(d);
              })
            svg.selectAll(".target_" + name)
              .style("stroke-opacity", 0.4)
              .style("stroke", function(d) {
                return colorConvert(d);
              })
          } else {
            svg.selectAll(".link")
              .style("stroke-opacity", 0);
            svg.selectAll(".target_" + name.substring(0, name.length - 1) + "1")
              .style("stroke-opacity", 0.4)
              .style("stroke", function(d) {
                return colorConvert(d);
              })
            svg.selectAll(".target_" + name.substring(0, name.length - 1) + "2")
              .style("stroke-opacity", 0.4)
              .style("stroke", function(d) {
                return colorConvert(d);
              })
          }
        });

      // add the rectangles for the nodes
      node.append("rect")
        .attr("height", function(d) {
          return d.dy;
        })
        .attr("width", sankey.nodeWidth())
        .style("fill", function(d) {
          d.color = color(d.name.substring(0, d.name.length - 1));
          return d3.rgb(d.color);
        })
        .style("stroke", function(d) {
          return d3.rgb(d.color).darker(1);
        })
        .append("title")
        .text(function(d) {
          return d.name + "\n" + format(d.value);
        });

      // add in the title for the nodes
      node.append("text")
        .attr("x", +35)
        .attr("y", function(d) {
          return d.dy / 2;
        })
        .attr("dy", ".35em")
        .attr("text-anchor", "start")
        .attr("transform", null)
        .text(function(d) {
          return d.name.substring(0, d.name.length - 1);
        })
        .filter(function(d) {
          return d.x < width / 2;
        })
        .attr("x", 6 + sankey.nodeWidth())
        .attr("text-anchor", "start");

      // the function for moving the nodes
      function dragmove(d) {
        d3.select(this).attr("transform",
          "translate(" + d.x + "," + (
            d.y = Math.max(0, Math.min(height - d.dy, d3.event.y))
          ) + ")");
        sankey.relayout();
        link.attr("d", path);
      }
    });

    function nameHash(name) {
      if (name.startsWith("Eng. Tech. & Drafting"))
        return "EngT" + name.charAt(name.length - 1);
      if (name.startsWith("Health Sci. & Techno."))
        return "HeaS" + name.charAt(name.length - 1);
      if (name.startsWith("Health Admin. & Assisting"))
        return "HeaA" + name.charAt(name.length - 1);
      if (name.startsWith("Commun, Fam., & Personal Svcs"))
        return "ComF" + name.charAt(name.length - 1);
      return name.substring(0, 4) + name.charAt(name.length - 1);
    }

    function colorConvert(d) {
      d.color = color(d.target.name.substring(0, d.target.name.length - 1));
      return d3.rgb(d.color);
    }
    </script>
</body>

</html>
